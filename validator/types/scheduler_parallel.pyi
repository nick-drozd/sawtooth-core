from google.protobuf.internal.containers import RepeatedScalarFieldContainer
from itertools import filterfalse
from sawtooth_validator.execution.scheduler import SchedulerIterator
from sawtooth_validator.protobuf.batch_pb2 import Batch
from sawtooth_validator.protobuf.transaction_pb2 import Transaction
from typing import (
    Any,
    Callable,
    List,
    Optional,
    Set,
)


def _first(iterator: filterfalse) -> None: ...


class ParallelScheduler:
    def __del__(self) -> None: ...
    def __init__(self, squash_handler: Callable, first_state_hash: str, always_persist: bool) -> None: ...
    def __iter__(self) -> SchedulerIterator: ...
    def _all_in_batch_have_results(self, txn_id: str) -> bool: ...
    def _any_in_batch_are_invalid(self, txn_id: str) -> bool: ...
    def _can_fail_fast(self, txn_id: str) -> bool: ...
    def _complete(self) -> bool: ...
    def _dependency_not_processed(self, txn: Transaction) -> bool: ...
    def _find_input_dependencies(
        self,
        inputs: RepeatedScalarFieldContainer
    ) -> List[str]: ...
    def _find_output_dependencies(
        self,
        outputs: RepeatedScalarFieldContainer
    ) -> List[str]: ...
    def _get_contexts_for_squash(self, batch_signature: str) -> List[str]: ...
    def _get_initial_state_for_transaction(
        self,
        txn: Transaction
    ) -> List[str]: ...
    def _has_predecessors(self, txn: Transaction) -> bool: ...
    def _index_of_batch(self, batch: Batch) -> int: ...
    def _index_of_txn_in_schedule(self, txn_id: str) -> int: ...
    def _is_explicit_request_for_state_root(self, batch_signature: str) -> bool: ...
    def _is_implicit_request_for_state_root(self, batch_signature: str) -> bool: ...
    def _is_in_same_batch(self, txn_id_1: str, txn_id_2: str) -> bool: ...
    def _is_last_valid_batch(self, batch_signature: str) -> bool: ...
    def _is_outstanding(self, txn: Transaction) -> bool: ...
    def _is_predecessor_of_possible_successor(self, txn_id: str, possible_successor: str) -> bool: ...
    def _is_txn_to_replay(self, txn_id: str, possible_successor: str, already_seen: List[Any]) -> bool: ...
    def _is_valid_batch(self, batch: Batch) -> bool: ...
    def _predecessor_not_in_chain(self, prior_txn_id: str, chain: List[Any]) -> bool: ...
    def _remove_subsequent_result_because_of_batch_failure(self, sig: str) -> None: ...
    def _reschedule_if_outstanding(self, txn_signature: str) -> bool: ...
    def _set_least_batch_id(self, txn_signature: str) -> None: ...
    def _sort_txn_ids_in_reverse(self, txn_ids: List[str]) -> List[str]: ...
    def _txn_failed_by_dep(self, txn: Transaction) -> bool: ...
    def _txn_is_in_valid_batch(self, txn_id: str) -> bool: ...
    def _txn_result_is_invalid(self, sig: str) -> bool: ...
    def _unscheduled_transactions(self) -> List[Transaction]: ...
    def add_batch(
        self,
        batch: Batch,
        state_hash: None = None,
        required: bool = False
    ) -> None: ...
    def available(self): ...
    def cancel(self) -> None: ...
    def complete(self, block: bool = True): ...
    def count(self): ...
    def finalize(self) -> None: ...
    def get_batch_execution_result(self, batch_signature: str): ...
    def get_transaction(self, index: int): ...
    def get_transaction_execution_results(self, batch_signature: str): ...
    def is_cancelled(self): ...
    def next_transaction(self): ...
    def set_transaction_execution_result(
        self,
        txn_signature: str,
        is_valid: bool,
        context_id: Optional[str],
        state_changes: None = None,
        events: None = None,
        data: None = None,
        error_message: str = '',
        error_data: bytes = b''
    ) -> None: ...
    def unschedule_incomplete_batches(self) -> None: ...


class PredecessorTree:
    def __init__(self, token_size: int = 2) -> None: ...
    def _get(
        self,
        address: str,
        create: bool = False
    ) -> PredecessorTreeNode: ...
    def _tokenize_address(self, address: str) -> List[str]: ...
    def add_reader(self, address: str, reader: str) -> None: ...
    def find_read_predecessors(self, address: str) -> Set[str]: ...
    def find_write_predecessors(self, address: str) -> Set[str]: ...
    def set_writer(self, address: str, writer: str) -> None: ...


class PredecessorTreeNode:
    def __init__(self, children: None = None, readers: None = None, writer: None = None) -> None: ...
