from itertools import filterfalse
from sawtooth_validator.execution.scheduler import (
    BatchExecutionResult,
    SchedulerIterator,
)
from sawtooth_validator.protobuf.batch_pb2 import Batch
from sawtooth_validator.protobuf.transaction_pb2 import Transaction
from typing import (
    Callable,
    List,
    Optional,
)


def _first(iterator: filterfalse) -> None: ...


class SerialScheduler:
    def __del__(self) -> None: ...
    def __init__(self, squash_handler: Callable, first_state_hash: str, always_persist: bool) -> None: ...
    def __iter__(self) -> SchedulerIterator: ...
    def _calculate_state_root_if_not_already_done(self) -> None: ...
    def _calculate_state_root_if_required(self, batch_id: str) -> None: ...
    def _check_change_last_good_context_id(self, txn: Transaction) -> None: ...
    def _complete(self) -> bool: ...
    def _compute_merkle_root(self, required_state_root: None) -> Optional[str]: ...
    def _dep_is_known(self, txn_id: str) -> bool: ...
    def _get_batch_result(self, txn_id: str) -> BatchExecutionResult: ...
    def _get_dependencies(self, transaction: Transaction) -> List[str]: ...
    def _handle_fail_fast(self, txn: Transaction) -> None: ...
    def _in_invalid_batch(self, txn_id: str) -> bool: ...
    def _set_batch_result(self, txn_id: str, valid: bool, state_hash: None) -> None: ...
    def add_batch(
        self,
        batch: Batch,
        state_hash: None = None,
        required: bool = False
    ) -> None: ...
    def cancel(self) -> None: ...
    def complete(self, block: bool): ...
    def count(self): ...
    def finalize(self) -> None: ...
    def get_batch_execution_result(self, batch_signature: str): ...
    def get_transaction(self, index: int): ...
    def get_transaction_execution_results(self, batch_signature: str): ...
    def is_cancelled(self): ...
    def next_transaction(self): ...
    def set_transaction_execution_result(
        self,
        txn_signature: str,
        is_valid: bool,
        context_id: Optional[str],
        state_changes: None = None,
        events: None = None,
        data: None = None,
        error_message: str = '',
        error_data: bytes = b''
    ) -> None: ...
    def unschedule_incomplete_batches(self) -> None: ...
